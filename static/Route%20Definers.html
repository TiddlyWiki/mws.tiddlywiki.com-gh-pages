<!doctype html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="generator" content="TiddlyWiki" />
<meta name="tiddlywiki-version" content="5.4.0-prerelease" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="mobile-web-app-capable" content="yes"/>
<meta name="format-detection" content="telephone=no">
<link id="faviconLink" rel="shortcut icon" href="favicon.ico">
<link rel="stylesheet" href="static.css">
<title>Route Definers: TiddlyWiki MultiWikiServer â€” TiddlyWiki for the People</title>
</head>
<body class="tc-body">
<p><div class="tc-static-alert"><div class="tc-static-alert-inner">This page is part of a static HTML representation of the TiddlyWiki at <a class="tc-tiddlylink-external" href="https://mws.tiddlywiki.com/" rel="noopener noreferrer" target="_blank">https://mws.tiddlywiki.com/</a></div></div>
</p>
<section class="tc-story-river tc-static-story-river">
<p><div class="tc-tiddler-frame tc-tiddler-view-frame tc-tiddler-exists  tc-tagged-Reference" data-tags="Reference" data-tiddler-title="Route Definers" role="article"><div class="tc-tiddler-title tc-clearfix"><div class="tc-titlebar"><span class="tc-tiddler-controls"><button aria-expanded="false" aria-label="more" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fmore-tiddler-actions" title="More actions"></button><span class=" tc-reveal" hidden="true"></span><button aria-label="Edit this tiddler" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fedit" title="Edit this tiddler"></button><button aria-label="close" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fclose" title="Close this tiddler"></button></span><span><h2 class="tc-title">Route Definers</h2></span></div><div class="tc-tiddler-info tc-popup-handle tc-reveal" hidden="true"></div></div><div class="tc-reveal"></div><div class=" tc-reveal"><div class="tc-subtitle tc-clearfix">13th May 2025 at 11:13pm</div></div><div class=" tc-reveal"><div class="tc-tags-wrapper"><span class="tc-tag-list-item" data-tag-title="Reference"><span aria-expanded="false" class="tc-tag-label tc-btn-invisible" draggable="true" style="fill:<<cssvar foreground>>;color:<<cssvar foreground>>;"><span class="tc-tag-exists">Reference</span></span><span class="tc-drop-down tc-reveal" hidden="true"></span></span></div></div><div class="tc-tiddler-body tc-clearfix tc-reveal"><div class="markdown">
<h2>Basic Route Definer</h2>
<p>The original route definer which I used to type TiddlyWiki server routes, but the types ended up being extremely complicated for what I actually ended up needing.  It is still used internally to actually define the routes, but the JavaScript side of it is very simple.
</p>
<dl>
<dt><code class="_codified_">method</code></dt>
<dd>A subset of the <a class="tc-tiddlylink tc-tiddlylink-resolves _codified_" href="Allowed%2520Methods.html">Allowed Methods</a>.</dd>
<dt><code class="_codified_">path</code></dt>
<dd>A regex starting with <code class="_codified_">^/</code> which matches the request. The first route handler which matches is used. Routes may be nested, and the full match is removed from the URL before matching children. If a parent route matches, it will be called, even if it has no child matches.</dd>
<dt><code class="_codified_">denyFinal</code></dt>
<dd>If this route matches, but none of its children do, the server will return <code class="_codified_">404 NOT FOUND</code>. Otherwise, its state handler will be called and expected to handle the request, even if none of its children match.</dd>
<dt><code class="_codified_">pathParams</code></dt>
<dd>An array of key names for regex match groups for the pathParams object.</dd>
<dt><code class="_codified_">bodyFormat</code></dt>
<dd>The <a class="tc-tiddlylink tc-tiddlylink-resolves _codified_" href="Body%2520Format.html">Body Format</a> which the request wishes to receive. If the method is only GET and HEAD, this is ignored, as no request body is expected. Internally, the request is probably drained early, just in case a body was sent.</dd>
<dt><code class="_codified_">handler</code> - a separate callback argument</dt>
<dd>If the route matches, the handler is called. The handler is called at each level in order, so parents may add additional (out of type) properties to the state object or handle some requests and allow others to go through to the matched child.</dd>
</dl>
<h3>Match result</h3>
<p>The StateObject has a routePath parameter containing the "path" through the "tree" of route definitions. In other words, it has the first matched route, and then the first matched child of that route, and then the first matched child of that route, and so on.
</p>
<p>It is an array of objects with the following properties.
</p>
<dl>
<dt><code class="_codified_">route</code></dt>
<dd>an object containing the options for the route listed above</dd>
<dt><code class="_codified_">params</code></dt>
<dd>an array of the match groups (<code class="_codified_">match.slice(1)</code>)</dd>
<dt><code class="_codified_">remainingPath</code></dt>
<dd>The remaining URL to match (if this is zero-length, it will be a <code class="_codified_">/</code>)</dd>
</dl>
<h2>Zod Route Definers</h2>
<p>The rest of the route definers are used by creating a class with the route definitions as properties, and then calling that class on server startup to register the routes.
</p>
<div style="color:rgb(212, 212, 212);background-color:rgb(30, 30, 30);font-family:&quot;font-size:15px;line-height:20px;white-space:pre;"><div><span style="color:#569cd6;">class</span> <span style="color:#4ec9b0;">RoutesClass</span> { <span style="color:#9cdcfe;">test</span> = <span style="color:#dcdcaa;">zodManage</span>(<span style="color:#9cdcfe;">z</span> <span style="color:#569cd6;">=&gt;</span> <span style="color:#9cdcfe;">z</span>.<span style="color:#dcdcaa;">any</span>(), <span style="color:#569cd6;">async</span> <span style="color:#9cdcfe;">e</span> <span style="color:#569cd6;">=&gt;</span> <span style="color:#569cd6;">null</span>) }</div><div><span style="color:#569cd6;">const</span> <span style="color:#4fc1ff;">RoutesKeyMap</span>: <span style="color:#4ec9b0;">RouterKeyMap</span>&lt;<span style="color:#4ec9b0;">RoutesClass</span>, <span style="color:#4ec9b0;">true</span>&gt; = { <span style="color:#9cdcfe;">test</span><span style="color:#9cdcfe;">:</span> <span style="color:#569cd6;">true</span> }</div><div><span style="color:#dcdcaa;">registerZodRoutes</span>(<span style="color:#4fc1ff;">root</span>, <span style="color:#569cd6;">new</span> <span style="color:#4ec9b0;">RoutesClass</span>(), <span style="color:#4ec9b0;">Object</span>.<span style="color:#dcdcaa;">keys</span>(<span style="color:#4fc1ff;">RoutesKeyMap</span>));</div></div>
<p><code class="_codified_">RoutesKeyMap</code> would have the keys of all the routes in the class, and the type makes sure no routes have been missed, while also allowing the class to have extra properties that are not routes.
</p>
<h2><code class="_codified_">zodRoute</code></h2>
<p>The <code class="_codified_">zodRoute</code> function creates type-safe route definitions with Zod validation. It takes a single configuration object with the following properties:
</p>
<dl>
<dt><code class="_codified_">method: string[]</code></dt>
<dd>An array of HTTP methods (e.g., <code class="_codified_">["GET", "POST"]</code>). Must be a subset of allowed methods.</dd>
<dt><code class="_codified_">path: string</code></dt>
<dd>A slash-separated string path with optional parameters prefixed with <code class="_codified_">:</code> (e.g., <code class="_codified_">"/recipes/:recipe_name/tiddlers/:title"</code>).</dd>
<dt><code class="_codified_">bodyFormat: BodyFormat</code></dt>
<dd>The expected body format: <code class="_codified_">"ignore"</code>, <code class="_codified_">"string"</code>, <code class="_codified_">"json"</code>, <code class="_codified_">"buffer"</code>, <code class="_codified_">"www-form-urlencoded"</code>, <code class="_codified_">"www-form-urlencoded-urlsearchparams"</code>, or <code class="_codified_">"stream"</code>. For GET and HEAD requests, this is always treated as <code class="_codified_">"ignore"</code>.</dd>
<dt><code class="_codified_">zodPathParams: (z: Z2&lt;"STRING"&gt;) =&gt; Record&lt;string, ZodType&gt;</code></dt>
<dd>A function that returns an object defining Zod validations for path parameters. The keys must match the parameter names in the path. If validation fails, returns 404.</dd>
<dt><code class="_codified_">zodQueryParams?: (z: Z2&lt;"STRING"&gt;) =&gt; Record&lt;string, ZodType&gt;</code></dt>
<dd>Optional function defining Zod validations for query parameters. Query params are arrays of strings by default.</dd>
<dt><code class="_codified_">zodRequestBody?: (z: Z2&lt;BodyFormat&gt;) =&gt; ZodType</code></dt>
<dd>Optional function defining Zod validation for the request body. Only valid for <code class="_codified_">"string"</code>, <code class="_codified_">"json"</code>, and <code class="_codified_">"www-form-urlencoded"</code> body formats. If validation fails, returns 400.</dd>
<dt><code class="_codified_">securityChecks?: { requestedWithHeader?: boolean }</code></dt>
<dd>Optional security checks. If <code class="_codified_">requestedWithHeader</code> is true, requires the <code class="_codified_">x-requested-with: fetch</code> header for non-GET/HEAD/OPTIONS requests.</dd>
<dt><code class="_codified_">corsRequest?: (state: ZodState&lt;"OPTIONS", "ignore", P, Q, ZodUndefined&gt;) =&gt; Promise&lt;symbol&gt;</code></dt>
<dd>Optional CORS preflight handler for OPTIONS requests. Cannot authenticate but can provide endpoint information.</dd>
<dt><code class="_codified_">inner: (state: ZodState&lt;Method, BodyFormat, PathParams, QueryParams, RequestBody&gt;) =&gt; Promise&lt;JsonValue&gt;</code></dt>
<dd>The main route handler that receives a fully validated and typed state object.</dd>
</dl>
<h3>Example</h3>
<pre><code>const getUser = zodRoute({
  method: ["GET"],
  path: "/users/:user_id",
  bodyFormat: "ignore",
  zodPathParams: z =&gt; ({
    user_id: z.string().uuid()
  }),
  zodQueryParams: z =&gt; ({
    include_roles: z.enum(["yes", "no"]).array().optional()
  }),
  inner: async (state) =&gt; {
    const { user_id } = state.pathParams; // typed as { user_id: string }
    const { include_roles } = state.queryParams; // typed as { include_roles?: ("yes"|"no")[] }
    
    return await getUserById(user_id, include_roles?.[0] === "yes");
  }
});
</code></pre>
<h2><code class="_codified_">admin</code> Helper Function</h2>
<p>The <code class="_codified_">admin</code> function is a convenience wrapper around <code class="_codified_">zodRoute</code> specifically for admin API endpoints. It automatically sets up:
</p>
<ul>
<li>Method: <code class="_codified_">["POST"]</code></li>
<li>Path: <code class="_codified_">"/admin/$key"</code> (where <code class="_codified_">$key</code> is replaced with the property name)</li>
<li>Body format: <code class="_codified_">"json"</code></li>
<li>Security: Requires <code class="_codified_">x-requested-with: fetch</code> header</li>
<li>Database transactions: Automatically wraps the handler in a Prisma transaction</li>
<li>Authentication: Provides access to authenticated user state</li>
</ul>
<h3>Signature</h3>
<pre><code>function admin&lt;T extends ZodTypeAny, R extends JsonValue&gt;(
  zodRequest: (z: Z2&lt;"JSON"&gt;) =&gt; T,
  inner: (state: ZodState&lt;"POST", "json", {}, {}, T&gt;, prisma: PrismaTxnClient) =&gt; Promise&lt;R&gt;
): ZodRoute&lt;"POST", "json", {}, {}, T, R&gt;
</code></pre>
<h3>Parameters</h3>
<dl>
<dt><code class="_codified_">zodRequest: (z: Z2&lt;"JSON"&gt;) =&gt; ZodType</code></dt>
<dd>Function defining the expected shape of the JSON request body.</dd>
<dt><code class="_codified_">inner: (state, prisma) =&gt; Promise&lt;JsonValue&gt;</code></dt>
<dd>Handler function that receives the validated state and a Prisma transaction client.</dd>
</dl>
<h3>Example</h3>
<pre><code>const user_create = admin(z =&gt; z.object({
  username: z.string().min(3),
  email: z.string().email(),
  role_id: z.string().uuid()
}), async (state, prisma) =&gt; {
  // state.data is typed based on the zodRequest schema
  const { username, email, role_id } = state.data;
  
  // Create user within the automatic transaction
  const user = await prisma.users.create({
    data: { username, email, role_id }
  });
  
  return { user_id: user.user_id, username, email };
});
</code></pre>
<h2><code class="_codified_">registerZodRoutes</code> Function</h2>
<p>This function registers multiple Zod routes from a class instance to a parent route. It's the bridge between route definitions and the actual router.
</p>
<h3>Signature</h3>
<pre><code>function registerZodRoutes(
  parent: ServerRoute,
  router: object,
  keys: string[]
): void
</code></pre>
<h3>Parameters</h3>
<dl>
<dt><code class="_codified_">parent: ServerRoute</code></dt>
<dd>The parent route to register child routes under.</dd>
<dt><code class="_codified_">router: object</code></dt>
<dd>An instance of a class containing route definitions as properties.</dd>
<dt><code class="_codified_">keys: string[]</code></dt>
<dd>Array of property names to register as routes. Usually <code class="_codified_">Object.keys(RouterKeyMap)</code>.</dd>
</dl>
<h3>Usage Pattern</h3>
<pre><code>export class UserManager {
  static defineRoutes(root: ServerRoute) {
    registerZodRoutes(root, new UserManager(), Object.keys(UserKeyMap));
  }

  user_create = admin(z =&gt; z.object({
    username: z.string(),
    email: z.string().email()
  }), async (state, prisma) =&gt; {
    // Implementation
  });

  user_list = admin(z =&gt; z.undefined(), async (state, prisma) =&gt; {
    // Implementation  
  });
}

export const UserKeyMap: RouterKeyMap&lt;UserManager, true&gt; = {
  user_create: true,
  user_list: true,
};

// Register during server startup
serverEvents.on("mws.routes", (root) =&gt; {
  UserManager.defineRoutes(root);
});
</code></pre>
</div></div>
</div></p>
</section>
</body>
</html>

